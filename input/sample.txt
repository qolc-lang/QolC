import "mylib" 
load "myFile"

/@ sample comment
myvar@"a string"

assert |5 > 2|

--d
x--
++y
g++
g += d
d -= g

anotherVar@5

hello@string|"Hello World!"|

an_int@int
x @ 3 + 5
y@float|5.0|
m@float^|null|

myFunc |x@float, y@float, z@float| \ float 
|@
	return x*y*z
@|

x@myFunc|2.0, 3.0, 5.0| + 6.0      /@ x is type is going to be float
f@float|x + 12|

vector3 struct
|@
	a@int
	b@float
	c@float
	myint5@int
	m74td@float
	e8i9o2@int|78|
	theNum3tyr33@53
	_hi57_32doo3y5@float|65|
	hello4537_npno212op33t1@float
	d@'d
@|

node struct 
|@
	node_a@node^! |null| 		/@ ! : memory ownership, if we delete this node struct, it will delete all of its child nodes 
	node_b@node^! |null|		
	myValue@int|---|			/@ --- : Intentional uninitialization for possible performance reasons 
@|

my_node@new node			/@ initialize the memory and returns it casted
my_node.node_a@new node
my_node.node_b@new node

delete my_node

super_node struct 
|@
	anode@node
	bnode@node
@|

new_super_node@super_node^!|new super_node|

hiNode@node|&new_super_node@.anode|

hexNum@ 0xfedcba9876543210

a@[50]int
b@[---]float

value enum
|@
	x @ 0,
	y,
	z @ y,
	v @ f,				
	g @ 10,
@|

f @ 2

flag@bool|true|
flag2@bool|~true|

defer print|"hello there"|

while |x <= y| 
|@
	print|x|
	x += y
	y -= x
	break
@|

if |x >= y| 
|@
	print|"Hello x", x|
	--y
	x++
	continue
@|
else if |x >= 10| 
|@
	print|"nanana"|
@|
else 
|@
	print|"Hello y", y|
@|

if |y < z| then return
if |z > z| then return

myArray@[---]int

each i@ 1 to n-1 
|@
	print|i|
	array_add|&myArray, cast|i, void^||
	sleep|2|
@|

it@int
for myArray print|it|

marines union 
|@
	decimal@float
	surname@[20]char
@|


main ||  
|@
	function_call||
	a@int
	b, c, ft @ string
	a /= |5 / 3|
	if |a ~= 0| 
	|@
		if |~false| 
			print|"heyy!!"|
	@|
	input@string
	scan|&input|
	print|input|
@|




////////////////////////////////////////////////////////////////////////////////////////////////////


#include<stdio.h>
#include<conio.h>
#include<alloc.h>
#include<string.h>
#include<stdlib.h>
#define NULL 0
int size = 0;
void Insert();
void Display();
void Delete();
int Search(char lab[]); void Modify();
struct SymbTab
{
	char label[10], symbol[10];
	int addr;
	struct SymbTab* next;
};
struct SymbTab* first, * last;
void main()
{
	int op, y;
	char la[10];
	clrscr();
	do
	{
		printf(“\n\tSYMBOL TABLE IMPLEMENTATION\n”);
		printf(“\n\t1.INSERT\n\t2.DISPLAY\n\t3.DELETE\n\t4.SEARCH\n\t5.MODIFY\n\t6.END\n”);
		printf(“\n\tEnter your option : “);
		scanf(“ % d”, &op);
		switch (op)
		{
		case 1:
			Insert();
			break;
		case 2:
			Display();
			break;
		case 3:
			Delete();
			break;
		case 4:
			printf(“\n\tEnter the label to be searched : “);
			scanf(“ % s”, la);
			y = Search(la);
			printf(“\n\tSearch Result : ”);
			if (y == 1)
				printf(“\n\tThe label is present in the symbol table\n”);
			else
				printf(“\n\tThe label is not present in the symbol table\n”);
			break;
		case 5:
			Modify();
			break;
		case 6:
			exit(0);
		}
	} while (op < 6);
	getch();
}
void Insert()
{
	int n;
	char l[10];
	printf(“\n\tEnter the label : “);
	scanf(“ % s”, l);
	n = Search(l);
	if (n == 1)
		printf(“\n\tThe label exists already in the symbol table\n\tDuplicate can’t be inserted”);
	else
	{
		struct SymbTab* p;
		p = malloc(sizeof(struct SymbTab));
		strcpy(p->label, l);
		printf(“\n\tEnter the symbol : “);
		scanf(“ % s”, p->symbol);
		printf(“\n\tEnter the address : “);
		scanf(“ % d”, &p->addr);
		p->next = NULL;
		if (size == 0)
		{
			first = p;
			last = p;
		}
		else
		{
			last->next = p;
			last = p;
		}
		size++;
	}
	printf(“\n\tLabel inserted\n”);
}
void Display()
{
	int i;
	struct SymbTab* p;
	p = first;
	printf(“\n\tLABEL\t\tSYMBOL\t\tADDRESS\n”);
	for (i = 0; i < size; i++)
	{
		printf(“\t % s\t\t % s\t\t % d\n”, p->label, p->symbol, p->addr);
		p = p->next;
	}
}
int Search(char lab[])
{
	int i, flag = 0;
	struct SymbTab* p;
	p = first;
	for (i = 0; i < size; i++)
	{
		if (strcmp(p->label, lab) == 0)
			flag = 1;
		p = p->next;
	}
	return flag;
}
void Modify()
{
	char l[10], nl[10];
	int add, choice, i, s;
	struct SymbTab* p;
	p = first;
	printf(“\n\tWhat do you want to modify ? \n”);
	printf(“\n\t1.Only the label\n\t2.Only the address\n\t3.Both the label and address\n”);
	printf(“\tEnter your choice : “);
	scanf(“ % d”, &choice);
	switch (choice)
	{
	case 1:
		printf(“\n\tEnter the old label : “);
		scanf(“ % s”, l);
		s = Search(l);
		if (s == 0)
			printf(“\n\tLabel not found\n”);
		else
		{
			printf(“\n\tEnter the new label : “);
			scanf(“ % s”, nl);
			for (i = 0; i < size; i++)
			{
				if (strcmp(p->label, l) == 0)
					strcpy(p->label, nl);
				p = p->next;
			}
			printf(“\n\tAfter Modification : \n”);
			Display();
		}
		break;
	case 2:
		printf(“\n\tEnter the label where the address is to be modified : “);
		scanf(“ % s”, l);
		s = Search(l);
		if (s == 0)
			printf(“\n\tLabel not found\n”);
		else
		{
			printf(“\n\tEnter the new address : “);
			scanf(“ % d”, &add);
			for (i = 0; i < size; i++)
			{
				if (strcmp(p->label, l) == 0)
					p->addr = add;
				p = p->next;
			}
			printf(“\n\tAfter Modification : \n”);
			Display();
		}
		break;
	case 3:
		printf(“\n\tEnter the old label : “);
		scanf(“ % s”, l);
		s = Search(l);
		if (s == 0)
			printf(“\n\tLabel not found\n”);
		else
		{
			printf(“\n\tEnter the new label : “);
			scanf(“ % s”, nl);
			printf(“\n\tEnter the new address : “);
			scanf(“ % d”, &add);
			for (i = 0; i < size; i++)
			{
				if (strcmp(p->label, l) == 0)
				{
					strcpy(p->label, nl);
					p->addr = add;
				}
				p = p->next;
			}
			printf(“\n\tAfter Modification : \n”);
			Display();
		}
		break;
	}
}
void Delete()
{
	int a;
	char l[10];
	struct SymbTab* p, * q;
	p = first;
	printf(“\n\tEnter the label to be deleted : “);
	scanf(“ % s”, l);
	a = Search(l);
	if (a == 0)
		printf(“\n\tLabel not found\n”);
	else
	{
		if (strcmp(first->label, l) == 0)
			first = first->next;
		else if (strcmp(last->label, l) == 0)
		{
			q = p->next;
			while (strcmp(q->label, l) != 0)
			{
				p = p->next;
				q = q->next;
			}
			p->next = NULL;
			last = p;
		}
		else
		{
			q = p->next;
			while (strcmp(q->label, l) != 0)
			{
				p = p->next;
				q = q->next;
			}
			p->next = q->next;
		}
		size–;
		printf(“\n\tAfter Deletion : \n”);
		Display();
	}
}


#endif // !_SYMBOL_TABLE_